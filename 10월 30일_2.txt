자바스크립트 코드를 자바스크립트 엔진이 call stack(+Memory Heap)을 이용해  single-thread방식으로 처리
single call stack을 가지고 있기 때문에 single-thread방식으로 동작하는 것
엔진이 코드를 execute할 때, 차례로 call stack에 쌓이게 된다.(단위-stack frame) 
single-thread방식에서는 multi-threaded환경에서 발생하는 deadlocks 같은 상황을 고려할 필요가 없어 좋지만,
이 역시 한계가 존재한다.
예를 들어 처리되기까지 많은 시간이 걸리는 함수가 호출되어 call stack에 쌓인 상황을 생각해보자.
call stack이 해당 함수를 처리하는 동안 브라우저는 아무 것도 할 수가 없다.(render or run any code)
이러한 대기 상황이 꽤 오랫동안 지속된다면 대부분의 브라우저는 에러를 발생시키고 사용자에게 웹 페이지를 종료할 것인지 물어본다.
이는 분명 사용자에게 불편함을 야기할 것이므로 해결책이 필요하다.
=> asynchronous callbacks : 다른 함수의 인자로 '함수'를 넘겨주는 것이다. 
setTimeout 같은 함수가 call stack에 들어오게 되면 Web API와 상호작용하고 타이머가 작동한다.
setTimeout함수는 call stack에서 나오게 되며 다음 작업이 call stack에 들어가게 된다.
타이머가 종료되면, setTimeout함수는 task queue에 삽입된다. 
event loop는 call stack이 비어있다면 setTimeout의 콜백함수를 실행하기 위해 call stack에 넣는다. 

Web API는 브라우저가 제공하며, 대표적으로 DOM, AJAX, setTimeout 등이 있다.

자바 스크립트는 멀티 스레드를 사용하지 않고 동시성을 구현한다. (콜백함수와 이벤트 루프를 이용)
비동기 함수는 호출하면 즉각 반환한다. 작업이 끝나지 않았더라도 반환함. 작업이 끝나고 결과물은 콜백함수나
메시지 전송을 통해 전달되지만 ＊＊즉각 반환되는 값에는 진짜 결과 값이 없다.＊＊ 
★콜백함수는 기대하는 일이 향후에 일어날 때 호출되는 함수이다.★
(기대하는 일)
-어떤 작업이 완료됨
-사용자가 프로그램과 상호작용함
-시간이 흐름
콜백함수는 어떤 활동을 표현하는 객체에 연결된다. 예를 들어 웹 브라우저에서 콜백 함수는 해당 DOM노드의 특정 속성에
할당되는 식으로 연결된다. 아니면 객체에 addEventListener()를 사용하여 콜백함수를 연결할 수도 있다.

이벤트 루프는 큐에서 가장 높은 우선순위를 가지는 이벤트 혹은 메시지를 가져와서 해당 이벤트나 메시지를 처리하도록
등록된 콜백함수를 호출해준다. 그리고 콜백함수가 작업을 완료하면 반환한다. 
콜백 함수는 방해받지 않기 때문에 경쟁이 일어날 필요도 없다. 
콜백함수가 반환되고 나면 이벤트 루프는 큐에서 그다음 이벤트나 메시지를 꺼내와서 등록된 콜백함수를 호출하고, 이 과정을
반복한다. 


 