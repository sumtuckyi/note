※Asynchronous / Synchronous

※Blocking / Non-blocking
: 동시에 두 가지 이상의 작업을 할 수 있는지 여부
-Blocking : 동시에 두 가지 이상의 작업을 수행할 수 없기 때문에 일반적으로 Asynchronous일 수 없음
Non-blocking&Asynchronous 방식으로 프로그램을 짰는데, 하나라도 Blocking한 요소가 존재한다면, 
의도치 않게 Blocking&Asynchronous한 상황이 발생할 수도 있다. 
-Non-blocking 
1)먼저 시작된 작업이 먼저 끝나는 경우(Synchronous) : (시작 순서: 1->2 / 종료 순서 : 1->2)
2)먼저 시작된 작업이 더 늦게 끝나는 경우(Asynchronous) : (시작 순서: 1->2 / 종료 순서 : 2->1)

※process와 thread
자바스크립트는 single thread 기반 언어이다. => 하나의 프로세스 내부에서 동시에 하나의 작업만 가능
=> 그렇다면 어떻게 Asynchronous하게 동작할 수 있는 거지? 
업무를 수행하는 주체가 하나인데...동시에 여러 작업을 수행하는 것처럼 보임
어떻게? -> 자바 스크립트가 동작할 수 있는 환경(runtime)의 도움을 받아 가능
자바 스크립트에서 비동기와 관련한 작업은 "브라우저" 또는 "노드"와 같은 환경에서 처리하는 것임

브라우저 환경에서의 자바스크립트 비동기 처리 관련 요소
1.자바스크립트 엔진의 Call Stack - 자바스크립트의 thread? (런타임이랑 관련 x)
call stack에 쌓인 작업이 바로 끝나지 않으니(자바스크립트는 기다려주지 않는다.) Web API로 해당 작업을 넘기고 새로운 작업을 받음
call stack에서 빠지면서 코드가 실행된다. 
-요청이 들어올 때마다 순차적으로 처리하는 스택
-기본적인 자바 스크립트의 싱글 스레드 작업 처리가 이루어지는 곳
2.Web API
-자바 스크립트 엔진이 아닌 브라우저에서 제공하는 런타임 환경
-시간이 소요되는 작업을 처리(예를 들어 setTimeout, DOM Event, ♥AJAX 요청♥ 등)
3.Task Queue : 대기열
-비동기 처리된 콜백함수가 대기하는 큐
4.Event Loop : Task Queue와 call stack을 감시
-작업이 들어오길 기다렸다가 작업이 들어오면 이를 처리하고, 처리할 태스크가 없는 경우에는 잠자는 상태.
-콜 스택과 태스크 큐를 지속적으로 모니터링
-콜 스택이 비어 있는지 확인 후 비어 있다면 태스크 큐에서 대기 중인 작업 중 가장 오래된 작업을 콜 스택으로 푸시 
(순서)
-모든 작업은 call stack으로 들어간 후 나오면서 처리된다. (한 번에 한 가지의 작업만 수행할 수 있다.)
-오래 걸리는 작업이 스택에 들어오면 웹 api로 보내 별도로 처리하도록 한다
-웹 api에서 처리(구체적으로 어떤 작업???)가 끝난 작업은 곧바로 call stack 으로 들어가지 못하고 큐에 순서대로 들어간다.
-이벤트 루프가 콜 스택이 비어 있는 것을 계속 체크하고 스택이 빈다면 큐에서 가장 먼저 들어온 작업을 스택으로 보낸다. 
실습 예제에서 3초 뒤에 콜백 함수는 태스크 큐로 가는 것이지 바로 출력됨을 보장하지 않는다.  

AJAX
: 자바스크립트의 비동기 구조와 XML 객체를 활용해 비동기적으로 서버와 통신하여 웹 페이지의 일부분만을
업데이트하는 웹 개발 기술(전체 페이지 reloading = 새로고침 없이 웹페이지를 렌더링 할 것임- 웹 페이지를 구성하는 요소 중 변화가 있는 요소만
업데이트 하는 것)
-XMLHttpRequest object : 자바스크립트를 사용하여 서버에 HTTP 요청을 할 수 있는 객체
여기서 HTTP 요청은 응답이 올 때까지 시간이 걸리는 작업이므로 비동기 API임
:서버와 상호작용할 때 사용하며 페이지의 새로고침 없이도 URL에서 데이터를 가져올 수 있음
:사용자의 작업을 방해하지 않고 페이지의 일부를 업데이트
event handler또한 비동기 프로그래밍의 한 형태

Axios 라이브러리
: 자바스크립트에서 사용되는 Promise기반의 HTTP 클라이언트 라이브러리 (비슷한 예로 파이썬의 requests 라이브러리)
☆☆☆<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>☆☆☆
-여러 http request method사용 가능
-then 메서드를 사용해서 성공하면 수행할 로직을 작성, catch 메서드를 사용해서 실패하면 수행할 로직을 작성 
-비동기로 데이터 통신을 가능하게 하는 라이브러리
-같은 방식으로 drf로 만든 api서버로 요청을 보내서 데이터를 받아온 후 처리할 수 있도록 함 

callback과 promise
: 비동기처리가 목적이라는 점은 같음 
왜 callback을 사용하는가? 
-★★비동기 처리의 핵심은 웹 API로 들어오는 순서가 아니라 작업이 완료되는 순서에 따라 처리한다는 것★★
-개발자 입장에서 코드의 실행 순서를 확실하게 알 수 없음 -> 실행 결과를 예측하면서 코드를 작성하는 것이 불가능함
=> 비동기 콜백 : 비동기적으로 처리되는 작업이 완료되었을 때 실행되는 함수 / 어떤 기능의 실행 결과를 받아서
다른 기능을 수행하기 위해 많이 사용됨
연쇄적으로 발생하는 ★비동기 작업을 순차적으로 동작★할 수 있게 함, BUT, 콜백 지옥에 빠질 수 잇음
=> 그렇다면 Promise를 사용하자..!
♥Promise♥ ? 자바스크립트에서 비동기 작업의 결과를 나타내는 object (♥비동기 작업의 완료 사실과 작업의 결과값(fulfillment value)임♥)
콜백과 동일한 역할, '작업이 끝나면 실행 시켜준다'는 약속.
비동기 작업의 완료 또는 실패를 나타내는 객체이다. : promise object의 method인 resolve(), reject()
비동기 작업이 하나 끝나면 해당 작업의 return 값(성공 또는 실패로 모두 promise object)을 인자로 받는 콜백함수를 then()이 인자로 받음. 
이 과정이 연쇄적(★chaining★)으로 이어짐(앞쪽의 콜백함수가 실행되고 나서야 그 다음 콜백함수가 비로소 실행되므로 작업에 순서 부여 가능)
then()중 하나라도 실패값을 반환하면 바로 이를 인자로 받는 콜백함수를 받는 catch()가 실행됨.

promise를 사용해도 chaining이 길어지면 가독성이 떨어진다는 단점이 있음
=> async & await를 이용해 동기 작업을 비동기 작업처럼 처리하도록 만들 수 있음
- await : 비동기 함수 내부 또는 모듈의 최상단에서 표현식(promise object) 앞에 붙여 사용한다.
＊표현식은 보통 promise를 리턴하는 함수
이 연산자를 사용하면 promise를 기다렸다가 promise의 fulfillment value를 받는다.
then()없이도 fulfillment value를 사용할 수 있다.
- async function : 

process란? -> 실행 중에 있는 프로그램
그럼 프로그램은 뭐야? -> 보조기억장치(하드디스크)에 저장되어 있는 명령어의 집합 + 정적 데이터 
프로그램을 실행하기 위해서는 하드디스크에서 필요한 데이터를 읽어와 주기억장치(RAM)에 메모리를 할당해야 하는데
이 시점부터 프로세스라고 칭한다.

thread란? -> 프로세스 내부에서 실제로 작업을 하는 주체 / 작업의 단위, 흐름이라고도 표현
프로그램을 작동시키기 위해 필요한 자원(메모리, cpu 할당 등)을 실제로 이용하는 단위
즉, 하나의 프로세스는 하나 이상의 thread로 구성된다. 

multi process는 뭘까? -> 여러 프로그램을 동시에 실행하는 것(RAM에 여러 개의 프로세스가 올라와 있는 것??)
예를 들어 유튜브 라이브를 재생하면서 채팅프로그램도 사용하고 vscode도  실행
cpu는 한 번에 하나의 연산만 수행할 수 있음 

multi thread는 뭐지? -> 하나의 프로세스 내에서 동시에 여러 thread로 작업을 실행하는 것
예를 들어 유튜브 라이브 내에서 영상 시청 + 채팅 입력이 동시에 이루어짐
thread끼리는 프로세스 내의 자원을 공유함 -> 한정된 자원을 두고 경쟁이 발생함
(공유된 자원에 여러 thread가 동시에 접근하는 '동시성 문제'가 발생) -> 동시화 기법으로 해결(Mutex, Semaphore)

★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆★☆
★Synchronous★
먼저 시작된 작업이 먼저 끝나는 경우

Synchronous function : 함수의 작업이 완료될 때까지 기다렸다가 값을 반환해야 계속 진행할 수 있음
★Asynchronous★ : 프로그램의 실행 흐름이 순차적이지 않으며, 작업이 완료되기를 기다리지 않고
다음 작업이 실행되는 방식
예) 메일 전송 버튼을 누르면 목록 화면으로 전환이 되지만, 실제로 메일을 보내는 작업은 병렬적으로 처리되고 있음,
브라우저는 웹페이지를 먼저 처리되는 요소부터 그려 나가며 처리가 오래 걸리는 것들은 별도로 처리가 완료되는대로 병렬적으로 처리,

callback function을 사용하는 이유 -> 

완료되지 않은 작업을 어디로 보내는 걸까?!!! ->  

Asynchronous 방식을 사용하는 이유 중 하나는 사용자 경험..! 