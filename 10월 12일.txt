article-comment의 외래키를 통한 관계 형성

역참조로 외래키를 통해 참조된 테이블도 관계를 맺고 있는 다른 테이블의 N개의 인스턴스에 접근 가능

오늘은 User table을 이 관계에 추가할 것임

Article(N)-User(1)
: 0개 이상의 게시글은 1명의 회원에 의해 작성될 수 있다. 
어떤 사용자가 쓴 게시글인지 어떻게 알 수 있을까? 
-> Article에 외래키를 두어 User 테이블을 참조

class User를 참조할 때, 
모델폼을 정의할 때, class Meta에 작성되는 모델이 장고 내장 USER모델이기 때문에
우리가 커스텀한 유저 모델로 이를 대체해주었다.
(get_user_model()함수를 이용하지 커스텀한 User 모델을 직접 참조하는 것은 지양하기를 권고-> 왜?
-> 모델 정보가 변경되더라도 일일이 수작업으로 바꿔줄 필요가 없음) 

다시 한 번 강조 -> ★User model은 직접 참조하지 않는다..!★
get_user_model() 은 객체(User Object)를 반환하고
settings.AUTH_USER_MODEL은 문자열(accounts.User)을 반환
가상환경에서 서버를 켰을 때, models.py가 구동될 때, 아직 User객체가 존재하지 않을 수도 있기 때문에
문자열로 참조하도록 하고 나중에 빌드가 완료되었을 때(즉, 유저 객체가 생성되었을 때)

이미 존재하는 테이블에 새로운 필드를 추가하는 경우 기존의 레코드의 해당 필드에 어떤 값을 넣을 것인지
설정해주어야 하는 경우(NULL값을 허용하지 않는 경우)처리 

모델폼을 사용하기 전 사용자가 입력한 데이터를 입력받을 때, plus_shell에서 그랬듯이 
article.save()를 사용,
모델폼을 사용하고 나서는 form.save()로 데이터를 db에 저장함.
여기서 두 메서드 save()는 같은 목적을 가지고 있지만 전자는 

※참고
장고 스타일 가이드
imports
-standard library
-third party
-Django

Comment(N)-User(1)
-현재 우리가 사용하고 있는 User모델은 내장모델을 대체한 것

data modeling 
: 데이터베이스 시스템을 시각적으로 표현하는 프로세스
-데이터 유형, 데이터 간의 관계를 분석

데이터 모델링 방식 중 하나로서 ERD

