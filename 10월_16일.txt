<M:N관계>
: 한 테이블의 0개 이상의 레코드가 다른 테이블의 0개 이상의 레코드와 관련된 경우
-> 양쪽 모두에서 N:1 관계를 가짐
예를 들어 의사와 환자 모델 간 관계에서, 한 명의 의사에게 여러 환자가 진료를 받을 수 있다.(1:N)
한 명의 환자는 여러 명의 의사에게 진료를 받을 수 있다.(1:N)                                                                                                      ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,, 

1:N 관계의 한계
한 필드에 여러 개의 속성값이 들어갈 수는 없다. (제약조건)
-> 일부 속성은 중복되더라도 한 테이블 내에서 새로운 인스턴스를 추가할 수밖에 없다.
 환자 테이블에서 의사 아이디가 외래키(FK), 의사 테이블에서는 의사 아이디가 PK
=> 중복없이 문제를 해결할 수 없을까? -> 새로운 테이블을 만들자!(예약 테이블)

중개 모델 
새로운 테이블에는 의사 아이디와 환자 아이디 필드가 존재. 두 필드 모두 외래키 역할
예약-환자(1:N) , 예약-의사(1:N)
환자와 의사 테이블에서 예약 테이블의 인스턴스에 접근하는 것은 역참조라고 한다.
장고는 역참조 매니저를 제공한다. 

??수동으로 관계 테이블을 매번 만들어야할까??
=> 장고는 ★★ManyToManyField★★를 제공한다!!(중개테이블을 ★★★자동★★★으로 생성해준다.)
환자 클래스의 속성으로 doctors 생성하는 것이 아님..! (!!DB에 필드가 추가되지  않음!!)
그렇지만 환자 테이블에서 의사 테이블은 참조가 가능함
아래와 같이 Patient class에서 ManyToManyField 작성
# doctors = models.ManyToManyField(Doctor) / models.ManyToManyField(to)
의사 테이블은 외래키 없음 -> 역참조를 해야함
만약 의사 테이블에서 
patients = models.ManyToManyField(Patient)로 바꿔서 사용해도 상관없음
-> ＊두 테이블 모두 어느쪽에도 종속되는 관계가 아니기 때문＊, 참조가능여부만 달라지는 것임
=> 참조하는 쪽에서는 ManyToManyField선언 시 할당한 변수명을 매니저로 사용
=> 역참조하는 쪽에서는 '본인이 참조되는 테이블 명_set'을 매니저로 사용


-M:N에서의 method 
:♥add(object), remove(object)♥로 관계의 생성과 삭제가 용이 
메서드로 새로운 관계를 생성하고 이는 중개 테이블의 인스턴스로 추가되지만 
★★ M:N관계로 맺어진 두 테이블에는 물리적인 변화가 없음★★
이 중개테이블에 추가적인 필드(관계를 맺고 있는 두 테이블의  pk이외)를 추가하고 싶으면?
-> 중개 테이블 수동 생성 + through argument사용
-> 관계 인스턴스는 어떻게 생성 ?
1) Reservation class를 통해 생성 : 일반적인 인스턴스 생성 방법
2) ManyToManyField를 추가한 클래스의 객체를 통해 생성 : 이때 add()에 through_defaults인자를 통해 딕셔너리
형태로 추가할 데이터를 전달

ManyToManyField(to, **options)
-related_name인자 : 역참조 시 사용하는 manager name을 변경(변경 전의 매니저 네임은 사용 못 함)
-symmetrical인자 : ManyToManyField가 동일한 모델(테이블)을 가리킬 때에만 사용(friends = models.ManyToManyField('self')),
이 인자값이 True(기본값)이면 관계의 방향을 고려하여 단방향으로 관계가 생성된다.(예를 들어 팔로우 기능)

M:N관계를 이용한 좋아요 기능 구현
=> 게시글-사용자 관계 + "좋아요" 중개테이블
ManyToManyField를 어떤 모델 클래스에 작성? -> 논리 흐름상 편한대로, 실습에선 Article에 두기로
★게시글-> 사용자 접근은 참조 / 사용자  -> 게시글 접근은 역참조★
 
N:1에서의 역참조
user.article_set.all()로 역참조
N:M에서의 역참조
user.article_set.all()로 역참조하므로 'article_set'이라는 동일한 manager name을 사용하게 됨


