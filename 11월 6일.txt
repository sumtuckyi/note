computed vs. method
접근 방식은 동일하지만 템플릿에서 메서드의 경우에는 'istrue()'처럼 표기
-메서드 호출은 렌더링이 발생할 때마다 함수가 실행된다는 점이 다름
-computed를 왜 사용하는가 ? -> 동일한 의존성을 여러 코드에서 사용할 때 계산 결과를 캐싱해놓고 사용하여
중복 계산을 방지한다. 

※CACHE 
데이터나 결과를 일시적으로 저장해두는 임시 저장소
렌더링 시에 캐시에 저장되어 있는 데이터라면 이를 사용하면 되기 때문에 더 빠르게 웹페이지를 그릴 수 있음

conditional rendering
: 특정 조건을 만족하는 경우에만 해당 요소를 렌더링하도록 함
-v-if / v-else : 해당 요소의 렌더링 여부를 전환
: 토글 비용이 높지만, false인 경우에는 초기 렌더링이 되지 않으므로 렌더링 비용이 낮음
-v-if / v-else-if / v-else  
(비교)
-v-show : 요소의 가시성(visibility)을 전환, 해당 요소의 style속성 중 display속성이 변경됨 (style="display: none;")
: 초기 렌더링 시에는 항상 렌더링 됨 / 대신 토글 비용이 낮음(항상 렌더링 되어 있기 때문에)

template element
: 웹 페이지에서 렌더링 되지는 않지만 java script로 조작할 html을 보유하기 위한 매커니즘
-> 보이지 않는 wrapper 

list rendering
-v-for : 반복가능한 소스데이터(array, object, number, string, iterable 등)를 기반으로 요소 또는 템플릿 블록을 여러 번 렌더링
: 반복되는 요소의 속성값(value), 키(key), index 모두에 접근이 가능하다. 
-데이터가 2차원 이상의 구조인 경우, 중첩된 v-for문을 이용하여 원하는 데이터에 접근할 수 있다. 
-★key★를 함께 사용 : 내부 컴포넌트의 상태를 일관되게 유지하기 위해 사용한다. 
이는 vue의 내부 동작과 관련이 있음. / 각 요소를 식별할 수 있는 unique한 값이어야 한다. 
-동일한 요소에서 v-for와 v-if를 함께 사용하지 않는다 : 동일 요소에서 v-if의 우선순위가 더 높으므로 에러가 발생

watch
: 반응형 데이터를 감시하고, 감시하는 데이터가 변경되면 콜백 함수(첫번째 인자는 변경된 값, 두번째 인자는 원래 값)를 호출한다. 콜백함수는 주로 감시하는 데이터의 연관 데이터를 업데이트 한다. 

computed vs. watchers
-전자는 템플릿 내에서 사용되는 데이터 연산용, 후자는 데이터 변경에 따른 특정 작업 처리용
-전자는 의존하는 데이터 속성의 계산된 값을 반환, 후자는 특정 데이터 속성의 변화를 감시하고 작업을 수행
-★둘 다 의존하는  원본데이터를 직접 변경하지는 않는다.★ 
※computed의 반환값은 변경하지 말 것 -> 읽기 전용값으로 취급할 것
※computed 내부에서 원본배열을 변경하지 않도록 배열을 복사해서 사용할 것
(참고) ★★원본 배열을 수정하지 않고 새 배열을 반환하는 메서드: filter(), concat(), slice()★★

Lifecycle Hooks
: Vue 인스턴스의 생애주기에서 특정 시점에 실행되는 함수 
Vue는 Lifecycle Hooks의 콜백함수와 해당하는 인스턴스를 자동으로 연결해줌

※생애주기
: 